import "server-only";
import type {
  InvoiceDto,
  InvoiceFormDto,
  IsoDateString,
} from "@/modules/invoices/application/dto/invoice.dto";
import type {
  InvoiceEntity,
  InvoiceFormEntity,
} from "@/modules/invoices/domain/entities/invoice.entity";
import {
  encodeInvoiceDateToIso,
  encodePeriodToFirstDay,
} from "@/modules/invoices/domain/invoice.codecs";
import { validateInvoiceStatus } from "@/modules/invoices/domain/invoice-status.validator";
import type { InvoiceStatus } from "@/modules/invoices/domain/statuses/invoice.statuses";
import { toCustomerId } from "@/shared/branding/converters/id-converters";
import type { AppError } from "@/shared/core/errors/core/app-error.entity";
import { Err, Ok } from "@/shared/core/results/result";
import type { Result } from "@/shared/core/results/result.types";

/**
 * Maps branded Entity to plain DTO.
 * Strips ALL branding for service/API layer.
 * Transport guarantees:
 * - amount is cents (integer)
 * - date is YYYY-MM-DD
 * - revenuePeriod is YYYY-MM-01 (first-of-month date)
 */
export function entityToInvoiceDto(entity: InvoiceEntity): InvoiceDto {
  const isoDate = encodeInvoiceDateToIso(entity.date); // YYYY-MM-DD
  const periodAsFirstDay = encodePeriodToFirstDay(entity.revenuePeriod); // YYYY-MM-01

  return {
    amount: entity.amount,
    customerId: String(entity.customerId),
    date: isoDate,
    id: String(entity.id),
    revenuePeriod: periodAsFirstDay,
    sensitiveData: entity.sensitiveData,
    status: entity.status,
  };
}

/**
 * Maps plain InvoiceFormDto to branded InvoiceFormEntity.
 * Input date expected as YYYY-MM-DD; server normalizes to Date.
 * Applies branding for database layer.
 * @exclude
 * Excludes `id` since IDs are generated by the database.
 * @exclude
 * Excludes `revenuePeriod` since it is derived.
 * @param dto - `InvoiceFormDto` from service layer
 */
export function dtoToCreateInvoiceEntity(
  dto: InvoiceFormDto,
): Result<InvoiceFormEntity, AppError> {
  const statusResult = validateInvoiceStatus(dto.status);
  if (!statusResult.ok) {
    return Err(statusResult.error);
  }

  return Ok({
    amount: dto.amount,
    customerId: toCustomerId(dto.customerId),
    date: new Date(dto.date as IsoDateString), // YYYY-MM-DD â†’ Date (UTC midnight)
    sensitiveData: dto.sensitiveData,
    status: statusResult.value,
  });
}

/**
 * Maps a partial InvoiceFormDto to a partial branded InvoiceFormEntity.
 * @param dto - Partial DTO from service layer
 * @returns Partial form entity for DAL
 */
export function partialDtoToCreateInvoiceEntity(
  dto: Partial<InvoiceFormDto>,
): Result<Partial<InvoiceFormEntity>, AppError> {
  let statusValue: InvoiceStatus | undefined;
  if (dto.status !== undefined) {
    const statusResult = validateInvoiceStatus(dto.status);
    if (!statusResult.ok) {
      return Err(statusResult.error);
    }
    statusValue = statusResult.value;
  }

  return Ok({
    ...(dto.amount !== undefined && { amount: dto.amount }),
    ...(dto.customerId !== undefined && {
      customerId: toCustomerId(dto.customerId),
    }),
    ...(dto.date !== undefined && {
      date: new Date(dto.date as IsoDateString),
    }),
    ...(dto.sensitiveData !== undefined && {
      sensitiveData: dto.sensitiveData,
    }),
    ...(statusValue !== undefined && { status: statusValue }),
  });
}
