import "server-only";

import {
  toCustomerId,
  toInvoiceId,
  toPeriod,
} from "@/core/types/domain-brands";
import type { InvoiceDto, InvoiceFormDto } from "@/features/invoices/dto";
import type {
  InvoiceEntity,
  InvoiceFormEntity,
  InvoiceServiceEntity,
} from "@/features/invoices/entity";
import { toInvoiceStatus } from "@/features/invoices/validator";
import type { InvoiceRow } from "@/server/db/schema";
import { isValidDate, toFirstOfMonth } from "@/shared/utils/date";

/**
 * Maps raw database row to branded Entity.
 */
export function rawDbToInvoiceEntity(row: InvoiceRow): InvoiceEntity {
  return {
    amount: row.amount,
    customerId: toCustomerId(row.customerId),
    date: row.date,
    id: toInvoiceId(row.id),
    revenuePeriod: toPeriod(row.revenuePeriod),
    sensitiveData: row.sensitiveData,
    status: toInvoiceStatus(row.status),
  };
}

/**
 * Maps branded Entity to plain DTO.
 * Strips ALL branding for service/API layer.
 */
export function entityToInvoiceDto(entity: InvoiceEntity): InvoiceDto {
  return {
    amount: entity.amount,
    customerId: String(entity.customerId),
    date: entity.date.toISOString(),
    id: String(entity.id),
    revenuePeriod: entity.revenuePeriod.toISOString(),
    sensitiveData: entity.sensitiveData,
    status: entity.status,
  };
}

/**
 * Maps plain InvoiceFormDto to branded InvoiceFormEntity.
 * Applies branding for database layer.
 * @exclude
 * Excludes `id` since IDs are generated by the database.
 * @exclude
 * Excludes `revenuePeriod` since it is derived from `date`.
 * @param dto - DTO from service layer
 */
export function dtoToCreateInvoiceEntity(
  dto: InvoiceFormDto,
): InvoiceFormEntity {
  return {
    amount: dto.amount,
    customerId: toCustomerId(dto.customerId),
    date: new Date(dto.date),
    sensitiveData: dto.sensitiveData,
    status: toInvoiceStatus(dto.status),
  };
}

/**
 * Maps branded InvoiceFormEntity to InvoiceServiceEntity.
 * Used for service layer operations.
 * @exclude
 * Excludes `id` since IDs are generated by the database.
 * @param formEntity - Branded form entity with valid Date object
 * @returns InvoiceServiceEntity with derived revenuePeriod
 * @throws Error if the date is invalid
 */
export function invoiceFormEntityToServiceEntity(
  formEntity: InvoiceFormEntity,
): InvoiceServiceEntity {
  // Validate the existing Date object
  if (!isValidDate(formEntity.date)) {
    throw new Error(`Invalid date in form entity: ${formEntity.date}`);
  }

  // Derive revenue period from the validated date
  const derivedRevenuePeriod = toFirstOfMonth(formEntity.date);

  return {
    ...formEntity,
    revenuePeriod: toPeriod(derivedRevenuePeriod),
  };
}

/**
 * Maps a partial InvoiceFormDto to a partial branded InvoiceFormEntity.
 * Ensures exact optional property types for strict TypeScript settings.
 * @param dto - Partial DTO from service layer
 * @returns Partial form entity for DAL
 */
export function partialDtoToCreateInvoiceEntity(
  dto: Partial<InvoiceFormDto>,
): Partial<InvoiceFormEntity> {
  return {
    ...(dto.amount !== undefined && { amount: dto.amount }),
    ...(dto.customerId !== undefined && {
      customerId: toCustomerId(dto.customerId),
    }),
    ...(dto.date !== undefined && { date: new Date(dto.date) }),
    ...(dto.sensitiveData !== undefined && {
      sensitiveData: dto.sensitiveData,
    }),
    ...(dto.status !== undefined && { status: toInvoiceStatus(dto.status) }),
  };
}
