import "server-only";

import { toInvoiceStatus } from "@/features/invoices/lib/mappers";
import type { InvoiceRow } from "@/server/db/schema/invoices";
import type {
  InvoiceEntity,
  InvoiceFormEntity,
  InvoiceServiceEntity,
} from "@/server/invoices/entity";
import {
  toCustomerId,
  toInvoiceId,
  toPeriod,
} from "@/shared/branding/id-converters";

import { isDateValid } from "@/shared/utils/date/guards";
import { toFirstDayOfMonthLocal } from "@/shared/utils/date/normalize";

/**
 * Maps raw database row to branded Entity.
 */
export function rawDbToInvoiceEntity(row: InvoiceRow): InvoiceEntity {
  return {
    amount: row.amount,
    customerId: toCustomerId(row.customerId),
    date: row.date,
    id: toInvoiceId(row.id),
    revenuePeriod: toPeriod(row.revenuePeriod),
    sensitiveData: row.sensitiveData,
    status: toInvoiceStatus(row.status),
  };
}

/**
 * Maps branded InvoiceFormEntity to InvoiceServiceEntity.
 * Used for service layer operations.
 * @exclude
 * Excludes `id` since IDs are generated by the database.
 * @param formEntity - `InvoiceFormEntity` Branded form entity with valid Date object
 */
export function invoiceFormEntityToServiceEntity(
  formEntity: InvoiceFormEntity,
): InvoiceServiceEntity {
  // Validate the existing Date object
  if (!isDateValid(formEntity.date)) {
    throw new Error(`Invalid date in form entity: ${formEntity.date}`);
  }

  // Derive revenue period from the validated date
  const derivedRevenuePeriod = toFirstDayOfMonthLocal(formEntity.date);

  return {
    ...formEntity,
    revenuePeriod: toPeriod(derivedRevenuePeriod),
  };
}
