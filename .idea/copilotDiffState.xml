<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/features/revenues/event-driven-architecture.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/features/revenues/event-driven-architecture.md" />
              <option name="originalContent" value="# Event-Driven Architecture for Revenues&#10;&#10;## Overview&#10;&#10;An event-driven architecture (EDA) enables decoupled, scalable, and maintainable systems by reacting to domain events. For the revenues feature, this means updating revenue records in response to invoice payment events.&#10;&#10;## Key Concepts&#10;&#10;- **Domain Events:** Represent significant business occurrences (e.g., `InvoicePaid`).&#10;- **Event Producers:** Emit events when business actions occur (e.g., invoice service emits `InvoicePaid`).&#10;- **Event Bus:** Dispatches events to interested listeners/handlers.&#10;- **Event Handlers:** React to events and perform business logic (e.g., update revenue records).&#10;&#10;## Implementation Steps&#10;&#10;### 1. Define Domain Events&#10;&#10;Create a domain event type for invoice payments:&#10;&#10;```typescript&#10;// src/features/revenues/domain/events/InvoicePaidEvent.ts&#10;export interface InvoicePaidEvent {&#10;  invoiceId: string;&#10;  paidAt: Date;&#10;  amount: number;&#10;  customerId: string;&#10;}&#10;```&#10;&#10;### 2. Emit Events from Invoice Logic&#10;&#10;When an invoice is marked as paid, emit an `InvoicePaidEvent`:&#10;&#10;```typescript&#10;// src/features/invoices/services/InvoiceService.ts&#10;import { EventBus } from 'src/lib/events/EventBus';&#10;import { InvoicePaidEvent } from 'src/features/revenues/domain/events/InvoicePaidEvent';&#10;&#10;async function markInvoicePaid(invoiceId: string) {&#10;  // ...existing logic...&#10;  EventBus.emit&lt;InvoicePaidEvent&gt;('InvoicePaid', {&#10;    invoiceId,&#10;    paidAt: new Date(),&#10;    amount,&#10;    customerId,&#10;  });&#10;}&#10;```&#10;&#10;### 3. Subscribe to Events in Revenues&#10;&#10;Create an event handler to update revenues:&#10;&#10;```typescript&#10;// src/features/revenues/domain/events/handlers/InvoicePaidHandler.ts&#10;import { EventBus } from 'src/lib/events/EventBus';&#10;import { InvoicePaidEvent } from './InvoicePaidEvent';&#10;&#10;EventBus.on&lt;InvoicePaidEvent&gt;('InvoicePaid', async (event) =&gt; {&#10;  // Update revenue records based on event data&#10;  // ...business logic...&#10;});&#10;```&#10;&#10;### 4. Decouple Revenue Updates&#10;&#10;Revenue logic should not directly depend on invoice logic. Instead, it reacts to events, improving modularity and testability.&#10;&#10;### 5. Error Handling &amp; Logging&#10;&#10;Log errors in event handlers and ensure failures do not block other event processing.&#10;&#10;### 6. Testing&#10;&#10;- Unit test event handlers.&#10;- Use integration tests to verify event flow.&#10;&#10;## Folder Structure Example&#10;&#10;```&#10;src/features/revenues/&#10;  domain/&#10;    events/&#10;      InvoicePaidEvent.ts&#10;      handlers/&#10;        InvoicePaidHandler.ts&#10;  services/&#10;    RevenueService.ts&#10;```&#10;&#10;## Benefits&#10;&#10;- Decouples invoice and revenue logic&#10;- Improves scalability and maintainability&#10;- Enables future extensibility (e.g., other events)&#10;&#10;## Next Steps&#10;&#10;- Refactor revenue logic to use event handlers&#10;- Ensure all invoice payment actions emit events&#10;- Consolidate and simplify revenue files for clarity&#10;&#10;---&#10;&#10;&gt; **Tip:** Use dependency injection for event handlers to improve testability and flexibility.&#10;&#10;" />
              <option name="updatedContent" value="# Event-Driven Architecture for Revenues&#10;&#10;## Overview&#10;&#10;An event-driven architecture (EDA) enables decoupled, scalable, and maintainable systems by reacting to domain events. For the revenues feature, this means updating revenue records in response to invoice payment events.&#10;&#10;## Key Concepts&#10;&#10;- **Domain Events:** Represent significant business occurrences (e.g., `InvoicePaid`).&#10;- **Event Producers:** Emit events when business actions occur (e.g., invoice service emits `InvoicePaid`).&#10;- **Event Bus:** Dispatches events to interested listeners/handlers.&#10;- **Event Handlers:** React to events and perform business logic (e.g., update revenue records).&#10;&#10;## Implementation Steps&#10;&#10;### 1. Define Domain Events&#10;&#10;Create a domain event type for invoice payments:&#10;&#10;```typescript&#10;// src/features/revenues/domain/events/InvoicePaidEvent.ts&#10;export interface InvoicePaidEvent {&#10;  invoiceId: string;&#10;  paidAt: Date;&#10;  amount: number;&#10;  customerId: string;&#10;}&#10;```&#10;&#10;### 2. Emit Events from Invoice Logic&#10;&#10;When an invoice is marked as paid, emit an `InvoicePaidEvent`:&#10;&#10;```typescript&#10;// src/features/invoices/services/InvoiceService.ts&#10;import { EventBus } from 'src/lib/events/EventBus';&#10;import { InvoicePaidEvent } from 'src/features/revenues/domain/events/InvoicePaidEvent';&#10;&#10;async function markInvoicePaid(invoiceId: string) {&#10;  // ...existing logic...&#10;  EventBus.emit&lt;InvoicePaidEvent&gt;('InvoicePaid', {&#10;    invoiceId,&#10;    paidAt: new Date(),&#10;    amount,&#10;    customerId,&#10;  });&#10;}&#10;```&#10;&#10;### 3. Subscribe to Events in Revenues&#10;&#10;Create an event handler to update revenues:&#10;&#10;```typescript&#10;// src/features/revenues/domain/events/handlers/InvoicePaidHandler.ts&#10;import { EventBus } from 'src/lib/events/EventBus';&#10;import { InvoicePaidEvent } from './InvoicePaidEvent';&#10;&#10;EventBus.on&lt;InvoicePaidEvent&gt;('InvoicePaid', async (event) =&gt; {&#10;  // Update revenue records based on event data&#10;  // ...business logic...&#10;});&#10;```&#10;&#10;---&#10;&#10;## Revenues Folder Structure &amp; Responsibilities&#10;&#10;The `src/features/revenues/` folder is organized by domain-driven design and clean architecture principles. Each child folder has a specific responsibility:&#10;&#10;### application/&#10;- **Purpose:** Application layer orchestrates business use cases and coordinates domain logic.&#10;- **Contents:** DTOs, mappers, services for business workflows, and application-level utilities.&#10;- **Example:** `RevenueService` for orchestrating revenue updates, DTOs for transferring data between layers.&#10;&#10;### domain/&#10;- **Purpose:** Contains core business logic, domain entities, value objects, events, repositories, and domain services.&#10;- **Contents:** Revenue types, domain events (e.g., `InvoicePaidEvent`), entities, repositories interfaces, and value objects.&#10;- **Example:** `RevenueEntity`, domain event definitions, repository contracts.&#10;&#10;### infrastructure/&#10;- **Purpose:** Implements technical details such as persistence, transactions, error handling, and event infrastructure.&#10;- **Contents:** Database adapters, event bus implementations, error handling utilities, transaction management.&#10;- **Example:** Database repositories, event bus setup, error handling strategies.&#10;&#10;### presentation/&#10;- **Purpose:** Handles user-facing actions, API endpoints, and presentation logic.&#10;- **Contents:** Server actions, API handlers, and presentation-specific utilities.&#10;- **Example:** Next.js server actions for revenue updates, API route handlers.&#10;&#10;### utils/&#10;- **Purpose:** Shared utilities and helpers used across the revenues feature.&#10;- **Contents:** Date calculators, batch processors, query builders, and other reusable logic.&#10;- **Example:** `DateRangeCalculator`, `BatchProcessor` for bulk operations.&#10;&#10;### validation/&#10;- **Purpose:** Input validation logic for revenue-related operations.&#10;- **Contents:** Schemas, validation functions, and error messages for validating user and system input.&#10;- **Example:** Zod schemas for revenue DTOs, custom validation functions.&#10;&#10;---&#10;&#10;## Best Practices&#10;- Keep each folder focused on its responsibility.&#10;- Use dependency injection for services and handlers to improve testability and flexibility.&#10;- Document all types, interfaces, and services with TSDoc.&#10;- Use strict TypeScript typing and modular architecture.&#10;&#10;---&#10;&#10;&gt; **Tip:** This structure supports event-driven updates, clean separation of concerns, and future extensibility for the revenues feature." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>